\documentclass[10pt,twocolumn]{article}% ===> this file was generated automatically by noweave --- better not edit it
\usepackage{noweb,hyperref,amsmath,amsthm,amssymb}
\noweboptions{smallcode,longchunks}
\newtheorem{Thm}{Theorem}
\newtheorem{Cor}[Thm]{Corollary}
\newtheorem{Lem}[Thm]{Lemma}
\theoremstyle{definition}
\newtheorem{Def}[Thm]{Definition}
\newtheorem{Rmk}[Thm]{Remark}
\begin{document}
\pagestyle{noweb}
\nwfilename{whatishyp.nw}\nwbegindocs{1}\nwdocspar
\title{{\Tt{}unhyp\nwendquote}}
\author{Robert C. Haraway, III\thanks{Research
partially supported by NSF grant DMS-1006553.}}
\maketitle
\paragraph{}
This is a literate {\Tt{}Python\nwendquote} module
to determine whether or not a compact
orientable 3-manifold\footnote{We work
in the PL category throughout.} with 
nonempty boundary\footnote{We require nonempty
boundary because Regina implements no
tests yet for small Seifert fiberings.} admits a complete 
hyperbolic metric on its interior.
\nwenddocs{}\nwbegindocs{2}\nwdocspar
The following corollary of Thurston's
hyperbolization theorem reduces this
determination to a question about
the existence of certain surfaces.
\begin{Cor}\label{cor:hyp}
A compact orientable 
bounded\footnote{That is, 
with nonempty boundary.} 
3-manifold with $\chi = 0$ 
is hyp iff
it has no faults.
\end{Cor}
\nwenddocs{}\nwbegindocs{3}\nwdocspar
The words ``hyp'' and ``fault'' mean the following.
\begin{Def}
A compact 3-manifold is \emph{hyp} just
when its interior admits a complete, finite
hyperbolic metric.
\end{Def}
\begin{Def}
Let $s$ be a properly embedded codimension-1 
submanifold of a connected p.l. manifold $M$. 
By abuse of notation,
also let $s$ denote the image of $s$ in $M$.
Pick a metric on $M$ compatible 
with its p.l. structure,
and let $M'$ be the (abstract, i.e. not in $M$)
path-metric completion of
$M \smallsetminus s$.

When $M'$ is disconnected, 
we say $s$ \emph{separates} $M$.

When $M'$ has two connected components
$N,N'$, we say $s$ \emph{cuts off (an)
$N$ from $M$}. When $M$ is understood
from context, we may say \emph{$s$ cuts off an $N$},
without reference to $M$.
When $N,N'$ are not homeomorphic, we say
$s$ cuts off \emph{one} $N$.
\end{Def}
\nwenddocs{}\nwbegindocs{4}\nwdocspar
\begin{Def}
A properly embedded surface $s$ 
in an orientable 3-manifold $M$ is a \emph{fault} 
iff $\chi(s) \geq 0$ and it satisfies one of the following:
\begin{itemize}
\item $s$ is nonorientable.
\item $s$ is a sphere which does not cut off a 3-ball.
\item $s$ is a disc which does not off one 3-ball.
\item $s$ is a torus which does not cut off a
$T^2 \times I$, and does not cut off
a $\partial$-compressible manifold.
\item $s$ is an annulus which does not cut off 
a 3-ball, and does not cut off one $D^2 \times S^1.$
\end{itemize}
\end{Def}
\nwenddocs{}\nwbegindocs{5}\nwdocspar
A proof of Corollary \ref{cor:hyp} is
sketched in \cite{Me}. Also found 
in \cite{Me} is the following algorithm,
which we implement in {\Tt{}Regina\nwendquote}:
\begin{verbatim}
l := fundamental normal surfaces in T
for surf in l:
  if surf is fault:
    return False
T' := finite truncation of T
if T' has a compressing disc:
  return False
l' := vertex Q-normal surfaces in T'
for annulus in l':
  if M has at least two boundary tori:
    if annulus is non-separating:
      return False
  else:
    if annulus is fault:
      return False
else:
  return True
\end{verbatim}
Here is an implementation in {\Tt{}Regina\nwendquote}.
\nwenddocs{}\nwbegincode{6}\moddef{algorithm for testing hypness}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
def unhypByNormalSurfaces(mfld):
  dno = mfld.getNumberOfBoundaryComponents()
  assert dno > 0
  if not possiblyHyp(mfld):
    return True
  \LA{}let T ideally triangulate mfld\RA{}
  \LA{}let l be fundamental surfaces of T\RA{}
  \LA{}for surf in l\RA{}
    if isFault(surf):
      return True
  \LA{}let TT finitely triangulate mfld\RA{}
  if TT.hasCompressingDisc():
    return True
  \LA{}let ll be vertex Q-normal surfaces of TT\RA{}
  \LA{}for surf in ll\RA{}
    if TT.getNumberOfBoundaryComponents() == 2:
      if isNonSeparatingAnnulus(surf):
        return True
    else:
      if isAnnulusFault(surf):
        return True
  else:
    return False

\nwendcode{}\nwbegincode{7}\moddef{possibly hyp}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
def possiblyHyp(mfld):
  m = mfld
  return m.isValid() \\
     and m.isOrientable() \\
     and m.getEulerCharManifold() == 0 \\
     and m.isConnected()

\nwendcode{}\nwbegincode{8}\moddef{let T ideally triangulate mfld}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
T = regina.NTriangulation(mfld)
T.finiteToIdeal()
T.intelligentSimplify()
\nwendcode{}\nwbegincode{9}\moddef{let l be fundamental surfaces of T}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
nsl = regina.NNormalSurfaceList.enumerate
std = regina.NS_STANDARD
fnd = regina.NS_FUNDAMENTAL
l = nsl(T,std,fnd)
\nwendcode{}\nwbegincode{10}\moddef{for surf in l}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
n = l.getNumberOfSurfaces()
for i in range(0,n):
  surf = l.getSurface(i)
\nwendcode{}\nwbegincode{11}\moddef{let TT finitely triangulate mfld}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
TT = regina.NTriangulation(mfld)
TT.idealToFinite()
TT.intelligentSimplify()
\nwendcode{}\nwbegincode{12}\moddef{let ll be vertex Q-normal surfaces of TT}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
vtx = regina.NS_VERTEX
qd  = regina.NS_QUAD
ll = nsl(TT,qd,vtx)
\nwendcode{}\nwbegincode{13}\moddef{for surf in ll}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
nn = ll.getNumberOfSurfaces()
for ii in range(0,nn):
  surf = ll.getSurface(ii)
\nwendcode{}\nwbegindocs{14}\nwdocspar
We need to implement the predicates
``is non-separating annulus,''
``is fault,'' and ``is $T^2 \times I.$''
\nwenddocs{}\nwbegindocs{15}\nwdocspar
First, the test for whether or not
a surface is a non-separating annulus.
\nwenddocs{}\nwbegincode{16}\moddef{is non-separating annulus}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
def separates(surf):
  M = surf.cutAlong()
  return not M.isConnected()

def isAnnulus(surf):
  return surf.hasRealBoundary()            \\
    and surf.getEulerCharacteristic() == 0 \\
    and surf.isOrientable()

def isNonSeparatingAnnulus(surf):
  return isAnnulus(surf) \\
     and not separates(surf)

\nwendcode{}\nwbegindocs{17}\nwdocspar
Next, the test for whether a surface
is an annulus fault.
\nwenddocs{}\nwbegincode{18}\moddef{is annulus fault}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
def isAnnulusFault(surf):
  return isAnnulus(surf) and \\
         isFault(surf)

\nwendcode{}\nwbegindocs{19}\nwdocspar
Later it will prove useful
to find a non-separating annulus
if one exists. So we do that here.
\nwenddocs{}\nwbegincode{20}\moddef{find non-separating annulus}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
def findNonSeparatingAnnulus(mfld):
  T = mfld
  \LA{}let l be fundamental surfaces of T\RA{}
  a = None
  \LA{}for surf in l\RA{}
    if isNonSeparatingAnnulus(surf):
      a = surf
      break
  return a

\nwendcode{}\nwbegindocs{21}\nwdocspar
Now let us implement a fault test.
This of course uses tests
for 3-ball, $\partial$-compression, $D^2 \times S^1$, 
and $T^2\times I$,
so abbreviate these.
\nwenddocs{}\nwbegincode{22}\moddef{tests}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
b = lambda m: m.isBall()
cd = lambda m: m.hasCompressingDisc()
d2s1 = lambda m: m.isSolidTorus()
t2i = isT2xI
\nwendcode{}\nwbegindocs{23}\nwdocspar
There aren't many quick sanity checks
to do, so we inline them (so to speak):
\nwenddocs{}\nwbegincode{24}\moddef{is fault?}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
def isFault(surf):
  s = surf
  x = s.getEulerCharacteristic()
  definitelyNotFault =     \\
    x < 0 or               \\
    not s.isConnected() or \\
    s.isVertexLink()
  if definitelyNotFault:
    return False
\nwendcode{}\nwbegindocs{25}\nwdocspar
At this point we know {\Tt{}s\nwendquote}
has nonnegative Euler characteristic.
If it's not orientable, then it's a fault.
\nwenddocs{}\nwbegincode{26}\moddef{is fault?}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  if not s.isOrientable():
    return True
\nwendcode{}\nwbegindocs{27}\nwdocspar
At this point, we know {\Tt{}s\nwendquote}
is orientable with nonnegative
Euler characteristic. So now
we cut along it and see what we get.
\nwenddocs{}\nwbegincode{28}\moddef{is fault?}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  M1 = s.cutAlong()
  M1.intelligentSimplify()
\nwendcode{}\nwbegindocs{29}\nwdocspar
If {\Tt{}s\nwendquote} doesn't cut off anything---i.e.
if {\Tt{}s\nwendquote} doesn't separate---then it is a fault.
\nwenddocs{}\nwbegincode{30}\moddef{is fault?}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  if M1.isConnected():
    return True
\nwendcode{}\nwbegindocs{31}\nwdocspar
Otherwise, it separates, and we should
look at the two pieces.
\nwenddocs{}\nwbegincode{32}\moddef{is fault?}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  assert M1.splitIntoComponents() == 2
  M2 = M1.getFirstTreeChild()
  M3 = M2.getNextTreeSibling()
  M2.idealToFinite()
  M2.intelligentSimplify()
  M3.idealToFinite()
  M3.intelligentSimplify()
\nwendcode{}\nwbegindocs{33}\nwdocspar
We run the tests now depending
on whether {\Tt{}s\nwendquote} is closed or bounded,
and depending on what its Euler
characteristic is.
\nwenddocs{}\nwbegindocs{34}\nwdocspar
When $s$ is a disc,\footnote{The
test for hypness below doesn't ever
run this code for discs, since we use {\Tt{}hasCompressingDisc\nwendquote}
to find disc faults. But we include this
for completeness.}
$s$ is a fault when 
$s$ does not cut off \emph{one} 3-ball.
So $s$ is a fault when either both $m_2,m_3$ are
balls or neither $m_2$ nor $m_3$ is a ball.
That is, when their ballnesses are equal, i.e.
$\mbox{ball}(m_2) = \mbox{ball}(m_3)$.
\nwenddocs{}\nwbegincode{35}\moddef{is fault?}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  if s.hasRealBoundary():
    if x == 1:
      # s is a disc
      return b(M2) == b(M3)
\nwendcode{}\nwbegindocs{36}\nwdocspar
When $s$ is a separating
annulus, $s$ is a fault when neither
$s$ cuts off \emph{a} 3-ball, nor
$s$ cuts off one solid torus.
\nwenddocs{}\nwbegincode{37}\moddef{is fault?}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
    else:
      # s had better be an annulus
      assert x == 0
      return not (b(M2) or b(M3)) \\
         and d2s1(M2) == d2s1(M3)
\nwendcode{}\nwbegindocs{38}\nwdocspar
The rest should be clear.
\nwenddocs{}\nwbegincode{39}\moddef{is fault?}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  else:
    # s is closed
    if x == 2:
      # s is a sphere
      return not (b(M2) or b(M3))
    else:
      # s had better be a torus
      assert x == 0
      return not (t2i(M2) or t2i(M3) \\
             or   cd(M2)  or cd(M3))

\nwendcode{}\nwbegindocs{40}\nwdocspar
Now for the next part,
$T^2 \times I$ detection
using Dehn filling.
\begin{Def}
Suppose $M$ is finitely triangulated. Let $T$, $T'$
be boundary triangles adjacent along an edge $e$.
Orient $e$ so that $T$ lies to its left
and $T'$ to its right. 

Let $\Delta$ be a fresh tetrahedron, 
and let $\tau$, $\tau'$
be boundary triangles of $\Delta$ adjacent
along an edge $\eta$. Orient $\eta$ so that
$\tau$ lies to its left and $\tau'$ to its right.
Without changing $M$'s topology we may glue
$\Delta$ to $T$ by gluing $\eta$ to $e$, 
$\tau$ to $T'$ and $\tau'$ to $T$. This is
called a \emph{two-two} move. 
The edge $\eta'$ opposite
$\eta$ in $\Delta$ is now a boundary edge of the
new finite triangulation.

We say $e$ is \emph{embedded} iff its
vertices are distinct. We say $e$ is
\emph{co-embedded} or \emph{foldable}
iff $\eta'$ is embedded.
\end{Def}
\nwenddocs{}\nwbegindocs{41}\nwdocspar
\begin{Rmk}
We call a co-embedded edge ``foldable'' for the
following reason. Given a boundary edge $e$ between
two boundary triangles $T$ and $T'$, one may
glue $T$ to $T'$ and $e$ to itself via a valid,
orientation-reversing map, 
folding them together along $e$.
This gluing will change the topology
of $M$ when the vertices opposite $e$ in $T$ and
$T'$ are the same vertex. Conversely, when these
vertices are distinct, the folding 
preserves the topology.
But the vertices are distinct 
iff $e$ is co-embedded.
Hence the name ``foldable.''
\end{Rmk}
\nwenddocs{}\nwbegindocs{42}\nwdocspar
Notice that folding along a foldable edge
decreases the number of boundary triangles,
and performing a two-two move on an embedded
edge produces a foldable edge and preserves
the number of boundary triangles. Therefore,
the following {\Tt{}while\nwendquote}-loops terminate:
\nwenddocs{}\nwbegindocs{43}\nwdocspar
\begin{verbatim}
while there's an embedded boundary edge e:
  do a two-two move on e
  while there's a foldable boundary edge f:
    fold along f
\end{verbatim}
\nwenddocs{}\nwbegindocs{44}\nwdocspar
The obvious postcondition of the {\Tt{}while\nwendquote}
loop is that there's no embedded boundary
edge. Since the boundary is still triangulated,
this is equivalent to each boundary component having
only one vertex on it. Since each boundary
component is a torus, $V - E + F = 0$.
Now, $V = 1$, and since the cellulation is
a triangulation, $3*F = 2*E$.
\begin{align*}
1 - E + F &= 0 \\
2 - 2*E + 2*F &= 0\\
2 - 3*F + 2*F &= 0\\
2 - F &= 0\\
2 &= F,
\end{align*}
and there are only two triangles. We may
fill any cusp we like by folding along
one of the remaining three (non-foldable) edges.
\nwenddocs{}\nwbegindocs{45}\nwdocspar
\begin{Rmk}
The routine in {\Tt{}SnapPea\nwendquote} is more complicated
because, rather than filling in a cusp any old way,
{\Tt{}SnapPea\nwendquote} wants to make sure the filling compresses
some given slope in the cusp.
\end{Rmk}
\nwenddocs{}\nwbegindocs{46}\nwdocspar
To implement this algorithm,
let us take stock of the tools {\Tt{}Regina\nwendquote} provides.
\nwenddocs{}\nwbegindocs{47}\nwdocspar
The algorithm is centered around edges,
and instances of {\Tt{}Regina\nwendquote}'s class {\Tt{}NEdge\nwendquote} represent
edges. {\Tt{}NEdge\nwendquote} has the following methods:
\begin{itemize}
\item {\Tt{}isBoundary\nwendquote}
\item {\Tt{}getVertex\nwendquote}
\item {\Tt{}getTriangulation\nwendquote}
\item {\Tt{}getEmbeddings\nwendquote}
\end{itemize}
Except for the first, they all do more or less
what you would expect. More specifically, if
{\Tt{}e\nwendquote} instantiates {\Tt{}NEdge\nwendquote} and represents
an edge $e$ in a triangulation $T$, then
{\Tt{}e.isBoundary()\nwendquote} is {\Tt{}True\nwendquote} iff $e$
is a boundary edge; {\Tt{}e.getVertex(0)\nwendquote} instantiates
{\Tt{}NVertex\nwendquote} and represents
the source of $e$, whereas {\Tt{}e.getVertex(1)\nwendquote}
represents its sink; and {\Tt{}e.getTriangulation()\nwendquote} is
instantiates {\Tt{}NTriangulation\nwendquote} and represents $T$.
\nwenddocs{}\nwbegindocs{48}\nwdocspar
In particular, here's a method to determine
whether or not an edge is embedded.
\nwenddocs{}\nwbegincode{49}\moddef{embedded edge?}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
def embedded(edge):
  src = edge.getVertex(0)
  snk = edge.getVertex(1)
  return src != snk

\nwendcode{}\nwbegindocs{50}\nwdocspar
{\Tt{}getEmbeddings\nwendquote} is more complicated, but
also more important. {\Tt{}e.getEmbeddings()\nwendquote} is
a list (in order) of instances of the class {\Tt{}NEdgeEmbedding\nwendquote}.
Let {\Tt{}phi\nwendquote} be an element of {\Tt{}e.getEmbeddings()\nwendquote}. 
{\Tt{}phi\nwendquote} represents an embedding $\phi$ of $e$
into an incident tetrahedron $\Delta$.
\nwenddocs{}\nwbegindocs{51}\nwdocspar
Some instance {\Tt{}phi.getTetrahedron()\nwendquote} of {\Tt{}NTetrahedron\nwendquote}
represents $\Delta$. Each instance {\Tt{}D\nwendquote} of {\Tt{}NTetrahedron\nwendquote}
comes with a method {\Tt{}D.getVertex\nwendquote}, which
represents an identification 
$j_\Delta:\mathbf{4} \to \Delta^0$
of $\mathbf{4} = \{0,1,2,3\}$ with the set
$\Delta^0$ of vertices of $\Delta$.
\nwenddocs{}\nwbegindocs{52}\nwdocspar
{\Tt{}phi.getVertices()\nwendquote}, perhaps confusingly,
is an instance of {\Tt{}NPerm4\nwendquote}. General
instances of {\Tt{}NPerm4\nwendquote} represent elements
of $S_{\mathbf{4}}$.
{\Tt{}phi.getVertices()\nwendquote} actually represents an element $f \in A_{\mathbf{4}}$,
the alternating group on $\mathbf{4}$, with the following
property. Let $s,s'$
be the source and sink of $e$. Then $\phi(s) = j_\Delta(f(0))$
and $\phi(s') = j_\Delta(f(1))$. 
\nwenddocs{}\nwbegindocs{53}\nwdocspar
We note that there are two elements 
of $S_{\mathbf{4}}$ satisfying
these equations, but only one in $A_{\mathbf{4}}$.
We choose the one in $A_{\mathbf{4}}$.
\nwenddocs{}\nwbegindocs{54}\nwdocspar
{\Tt{}e.getEmbeddings()\nwendquote} is ordered so that we can 
give a consistent orientation to the edges
opposite $e$, in the following way:
\nwenddocs{}\nwbegindocs{55}\nwdocspar
\begin{quote}
Let {\Tt{}l\ =\ e.getEmbeddings()\nwendquote} have length $n$;
for all $i$ with $0 \leq i < n$, let {\Tt{}l[i]\nwendquote} 
represent the embedding $\phi_i$;
let {\Tt{}l[i].getTetrahedron()\nwendquote} represent $\Delta_i$;
let $j_i = j_{\Delta_i}$; and
let {\Tt{}l[i].getVertices()\nwendquote} represent $f_i$.
Then for all $i$ with $1 \leq i < n - 1$, 
the vertices $j_{i-1}(f_{i-1}(3))$ and $j_{i}(f_{i}(2))$
are glued in the triangulation.
\end{quote}
\nwenddocs{}\nwbegindocs{56}\nwdocspar
Furthermore, if $e$ is a boundary edge,
then each of {\Tt{}l[0]\nwendquote} and {\Tt{}l[-1]\nwendquote} (i.e. the last
element of {\Tt{}l\nwendquote}) represents an embedding of
$e$ into the boundary. In particular, if
$j_0(f_0(2))$ becomes the vertex $v$ in the
triangulation and $j_{-1}(f_{-1}(3))$ becomes $w$,
then $v$ and $e$ determine a boundary face, and so
do $w$ and $e$.
\nwenddocs{}\nwbegindocs{57}\nwdocspar
We should
finally explain another method 
{\Tt{}NTetrahedron\nwendquote} provides, namely {\Tt{}joinTo\nwendquote}.
Suppose $\Delta,H$ are tetrahedra.
How shall we join them up? Glue them along
faces. How shall we name faces? Call faces
by their opposite vertices. How shall we
determine a gluing map? Well, let $p$
be a gluing map from the face $v_\ast$ opposite $v$ in $\Delta$
to the face $w_\ast$ opposite $w$ in $H$. Then $p$
restricted to the vertices of the 
faces has a unique extension to a bijection
$P:\Delta^0 \to H^0$. Then we get a uniquely determined
element $\sigma_p = j_H^{-1} \circ P \circ j_\Delta$
of $S_{\mathbf{4}}$. 
\nwenddocs{}\nwbegindocs{58}\nwdocspar
Conversely, for any such element
$s \in S_{\mathbf{4}}$, there is a unique affine
map $\pi_s: v_\ast \to w_\ast$ such that
$\sigma_{\pi_s} = s$. 
\nwenddocs{}\nwbegindocs{59}\nwdocspar
So we may determine a gluing by
\begin{itemize}
\item which tetrahedra we're gluing,
\item which faces are getting glued, and
\item what is the associated element of $S_{\mathbf{4}}$.
\end{itemize}
\nwenddocs{}\nwbegindocs{60}\nwdocspar
In {\Tt{}Regina\nwendquote} it's more spartan than that. First of all,
every instance of {\Tt{}NTetrahedron\nwendquote} has the child method {\Tt{}joinTo\nwendquote}.
There's no need to include that instance as an argument
to the procedure; {\Tt{}joinTo\nwendquote} implicitly regards its parent tetrahedron
as $\Delta$ above. Also, given the permutation and the
face on $\Delta$ to glue, the face on $H$ is determined, so
that face need not be included as an argument to {\Tt{}joinTo\nwendquote}. 
\nwenddocs{}\nwbegindocs{61}\nwdocspar
In conclusion, 
\begin{verbatim}
D.joinTo(i,E,s)
\end{verbatim}
is the {\Tt{}Regina\nwendquote} syntax for gluing 
tetrahedron {\Tt{}D\nwendquote} to a tetrahedron {\Tt{}E\nwendquote}
by gluing the face in {\Tt{}D\nwendquote} opposite {\Tt{}D.getVertex(i)\nwendquote}
to the face in {\Tt{}E\nwendquote} opposite {\Tt{}E.getVertex(s(i))\nwendquote}
by the map determined by {\Tt{}s\nwendquote}.
\nwenddocs{}\nwbegindocs{62}\nwdocspar
Therefore, we care primarily about
tetrahedra and permutation representatives, and 
not so much about the edge embeddings
$\phi_i$ themselves. In fact, since
ultimately we're only concerned with boundary edges,
all we care about are $f_0, f_{-1}, \Delta_0,$ 
and $\Delta_{-1}$. So let's write methods 
to return their representatives.
\nwenddocs{}\nwbegincode{63}\moddef{left and right maps and tets}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
def lrmaps(edge):
  embs = edge.getEmbeddings()
  return (embs[0].getVertices(),\\
          embs[-1].getVertices())

def lrtets(edge):
  embs = edge.getEmbeddings()
  return (embs[0].getTetrahedron(),\\
          embs[-1].getTetrahedron())

\nwendcode{}\nwbegindocs{64}\nwdocspar
We've already written a method for
determining whether or not an edge is embedded.
Let's write a method to determine whether or not
it's coembedded.
\nwenddocs{}\nwbegindocs{65}\nwdocspar
The definition we gave already
was quick, but implementing it 
is altogether unnecessary, for with
the terminology we have now, there is
a better characterization of foldability.
First of all, an edge had better be
a boundary edge if it is going to be foldable.
\nwenddocs{}\nwbegincode{66}\moddef{foldability}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
def foldable(edge):
  if not edge.isBoundary():
    return False
\nwendcode{}\nwbegindocs{67}\nwdocspar
As we've set it up, the tetrahedra
and permutations are as follows:
\nwenddocs{}\nwbegincode{68}\moddef{foldability}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  (F0,F_1) = lrmaps(edge)
  (D0,D_1) = lrtets(edge)
\nwendcode{}\nwbegindocs{69}\nwdocspar
Now, an edge $e$ is coembedded iff it becomes
embedded after a two-two move. This is equivalent
to saying that the vertices opposite $e$ in the
boundary faces are distinct. But these vertices
are $j_0(f_0(2))$ and $j_{-1}(f_{-1}(3))$. So
we can just test equality of these.
\nwenddocs{}\nwbegincode{70}\moddef{foldability}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  lvx = D0.getVertex(F0[2])
  rvx = D_1.getVertex(F_1[3])
  return lvx != rvx

\nwendcode{}\nwbegindocs{71}\nwdocspar
Having finished the foldability test,
let us now implement the next part of the
algorithm, viz. a two-two move on a boundary edge.
This attaches a fresh tetrahedron $t$ to the
triangulation of the edge.
\nwenddocs{}\nwbegincode{72}\moddef{two-two move}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
def twoTwo(edge):
  M = edge.getTriangulation()
  T = M.newTetrahedron()
\nwendcode{}\nwbegindocs{73}\nwdocspar
Use the same notation as above.
\nwenddocs{}\nwbegincode{74}\moddef{two-two move}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  (F0,F_1) = lrmaps(edge)
  (D0,D_1) = lrtets(edge)
\nwendcode{}\nwbegindocs{75}\nwdocspar
Now the faces adjacent to $e$ are
opposite the vertices $j_0(f_0(3))$
and $j_{-1}(f_{-1}(2))$. We wish
to glue to these faces the two faces of $t$ 
that include both $j_t(0)$ and $j_t(1)$. These
are the faces opposite $j_t(2)$ and $j_t(3)$.
\nwenddocs{}\nwbegindocs{76}\nwdocspar
To determine what the gluing maps should be, 
we may just follow the lead of {\Tt{}getEdgeEmbedding\nwendquote} 
and insist that $j_0(f_0(3))$ get glued to $j_t(2)$
and $j_{-1}(f_{-1}(3))$ to $j_t(3)$. (If such insistence
isn't convincing, draw a picture.)
\nwenddocs{}\nwbegindocs{77}\nwdocspar
The first gluing map also sends $j_t(0)$ to $f_0(0)$
and $j_t(1)$ to $f_0(1)$. So the associated permutation $s_0$
is plainly $f_0$ precomposed with the cycle $x = (2~3)$.
The same is true for the other gluing map's permutation $s_{-1}$, 
except with $f_{-1}$ instead of $f_0$.
\nwenddocs{}\nwbegincode{78}\moddef{two-two move}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  X = regina.NPerm(2,3)
  S0 = F0 * X
  S_1 = F_1 * X
  T.joinTo(2,D0,S0)
  T.joinTo(3,D_1,S_1)

\nwendcode{}\nwbegindocs{79}\nwdocspar
The last nontrivial operation we must implement
is to fold along a boundary edge. We must first
insist that the edge be a boundary edge.
\nwenddocs{}\nwbegincode{80}\moddef{fold along a boundary edge}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
def foldAlong(edge):
  assert edge.isBoundary()
\nwendcode{}\nwbegindocs{81}\nwdocspar
Use the same notation as before.
\nwenddocs{}\nwbegincode{82}\moddef{fold along a boundary edge}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  (D0,D_1) = lrtets(edge)
  (F0,F_1) = lrmaps(edge)
\nwendcode{}\nwbegindocs{83}\nwdocspar
The face $\ell$ of $\Delta_0$ to be glued is
the face opposite $j_0(f_0(3))$, and the
face $\ell'$ of $\Delta_{-1}$ to be glued is
the face opposite $j_{-1}(f_{-1}(2))$.
So to glue $\ell$ to $\ell'$, we need
a permutation fixing $0$ and $1$, and
taking $f_0(3)$ to $f_{-1}(2)$. This
permutation is $f_{-1} \circ (2~3) \circ f_{0}^{-1}$.
\nwenddocs{}\nwbegincode{84}\moddef{fold along a boundary edge}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  X = regina.NPerm(2,3)
  glu = F_1 * X * F0.inverse()
  D0.joinTo(F0[3], D_1, glu)

\nwendcode{}\nwbegindocs{85}\nwdocspar
This concludes the difficult portion
of the implementation. The rest is simple.
\nwenddocs{}\nwbegindocs{86}\nwdocspar
The first and second {\Tt{}while\nwendquote} loops don't
have implementations as such in {\Tt{}Python\nwendquote}.
We can simulate them by implementing an
operation that returns either the first
boundary edge satisfying a predicate,
or the {\Tt{}Python\nwendquote} primitive {\Tt{}None\nwendquote} if
there is no such edge.
\nwenddocs{}\nwbegincode{87}\moddef{first boundary edge}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
def firstBoundaryEdge(mfld,pred):
  cpts = mfld.getBoundaryComponents()
  for d in cpts:
    n = d.getNumberOfEdges()
    for i in range(0,n):
      e = d.getEdge(i)
      if pred(e):
        return e
  else:
    return None

\nwendcode{}\nwbegindocs{88}\nwdocspar
This uses the {\Tt{}Python\nwendquote} idiom
of an {\Tt{}else\nwendquote} clause after a {\Tt{}for\nwendquote} loop.
\nwenddocs{}\nwbegindocs{89}\nwdocspar
Now we are ready to implement the {\Tt{}while\nwendquote} loops.
\nwenddocs{}\nwbegincode{90}\moddef{simplify cusps}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
def simplifyCusps(finite_mfld):
  M = finite_mfld
  fBE = firstBoundaryEdge
  f = fBE(M,embedded)
  while f != None:
    twoTwo(f)
    g = fBE(M,foldable)
    while g != None:
        foldAlong(g)
        g = fBE(M,foldable)
    f = fBE(M,embedded)

\nwendcode{}\nwbegindocs{91}\nwdocspar
To implement the $T^2\times I$ test,
now we just need to implement a routine
as described in \cite{Me}. We need to
first make sure the manifold is irreducible
and $\partial$-incompressible. There isn't
at present an explicit method for irreducibility
of bounded manifolds in Regina, so we roll
our own very slow method. We define {\Tt{}isFault\nwendquote} below,
which is allowed in {\Tt{}Python\nwendquote}.
\nwenddocs{}\nwbegincode{92}\moddef{is $T^2 \times I$?}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
def irreducible(regina_mfld):
  M = regina.NTriangulation(regina_mfld)
  M.finiteToIdeal()
  M.intelligentSimplify()
  nsl = regina.NNormalSurfaceList.enumerate
  l = nsl(M, regina.NS_STANDARD,  \\
             regina.NS_FUNDAMENTAL)
  n = l.getNumberOfSurfaces()
  for i in range(0,n):
    s = l.getSurface(i)
    x = s.getEulerCharacteristic()
    if x != 2:
      continue
    if isFault(s):
      return False
  else:
    return True

def isT2xI(regina_mfld):
  M = regina.NTriangulation(regina_mfld)
  M.finiteToIdeal()
  M.intelligentSimplify()
\nwendcode{}\nwbegindocs{93}\nwdocspar
There are some sanity checks we can run here
before the irreducibility and 
$\partial$-incompressibility tests
to save time---e.g. whether the manifold
is connected, whether it has two torus
boundary components, and so on. Put these
sanity checks under the umbrella function
{\Tt{}possiblyT2xI\nwendquote}, and implement this later.
\nwenddocs{}\nwbegincode{94}\moddef{is $T^2 \times I$?}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  if not possiblyT2xI(M):
    return False
\nwendcode{}\nwbegindocs{95}\nwdocspar
Now we implement our test. We point
out that since we end up simplifying
the cusps and doing three
fillings, we make a clone of $N$ of
$M$, simplify $N$'s cusps, then
clone $N$ three times before filling
along the three slopes. We also note
that {\Tt{}simplifyCusps\nwendquote} simplifies
all boundary components' triangulations
as specified in \cite{Me}.
\nwenddocs{}\nwbegincode{96}\moddef{is $T^2 \times I$?}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  if not irreducible(M):
    return False
  if M.hasCompressingDisc():
    return False
  a = findNonSeparatingAnnulus(M)
  if a == None:
    return False
  mu = a.cutAlong()
  mu.intelligentSimplify()
  if not mu.isSolidTorus():
    return False
  D = regina.NTriangulation(M)
  simplifyCusps(D)
  T = D.getBoundaryComponent(1)
  n = T.getNumberOfEdges()
  assert n == 3
  for i in range(0,n):
    clone = regina.NTriangulation(D)
    cpt = clone.getBoundaryComponent(1)
    e = cpt.getEdge(i)
    foldAlong(e)
    if not clone.isSolidTorus():
      return False
  else:
    return True

\nwendcode{}\nwbegindocs{97}\nwdocspar
Now we should get around to implementing
the remaining sanity checks.

\nwenddocs{}\nwbegincode{98}\moddef{possibly $T^2 \times I$}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
def possiblyT2xI(mfld):
  m = mfld
  dno = m.getNumberOfBoundaryComponents()
  if not (possiblyHyp(m) and dno == 2):
    return False
  cpts = m.getBoundaryComponents()
  for d in cpts:
    x = d.getEulerCharacteristic()
    if x != 0:
      return False
  H1 = m.getHomologyH1()
  if not H1.toString() == '2 Z':
    return False
  H2 = m.getHomologyH2()
  if not H2.isZ():
    return False
  H1R = m.getHomologyH1Rel()
  if not H1R.isZ():
    return False
  return True

\nwendcode{}\nwbegincode{99}\moddef{has torus boundary?}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
def hasTorusBoundary(mfld):
  m = mfld
  if m.isClosed():
    return False
  for v in m.getVertices():
    if not v.getLink() == regina.NVertex.TORUS:
      return False
  return True

\nwendcode{}\nwbegindocs{100}\nwdocspar
Finally, the code at present has the following
flaw: that it verifies hyperbolicity
by enumerating all fundamental normal
surfaces of a certain flavor, and checking
that they are not faults. This takes
a long time, and there is now a better
routine which may verify hyperbolicity.
This method is part of {\Tt{}Regina\nwendquote}; it
detects whether a triangulation admits
a strict angle structure, existence of which is a
sufficient condition for hyperbolicity.
\nwenddocs{}\nwbegincode{101}\moddef{is hyp?}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
def isHyp(regina_manifold):
  m = regina.NTriangulation(regina_manifold)
  m.intelligentSimplify()
  if m.hasStrictAngleStructure():
    return True
  else:
    return not unhypByNormalSurfaces(m)

\nwendcode{}\nwbegincode{102}\moddef{unhyp.py}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
import regina
\LA{}possibly hyp\RA{}
\LA{}is non-separating annulus\RA{}
\LA{}is annulus fault\RA{}
\LA{}find non-separating annulus\RA{}
\LA{}embedded edge?\RA{}
\LA{}left and right maps and tets\RA{}
\LA{}foldability\RA{}
\LA{}two-two move\RA{}
\LA{}fold along a boundary edge\RA{}
\LA{}first boundary edge\RA{}
\LA{}simplify cusps\RA{}
\LA{}possibly $T^2 \times I$\RA{}
\LA{}has torus boundary?\RA{}
\LA{}is $T^2 \times I$?\RA{}
\LA{}tests\RA{}
\LA{}is fault?\RA{}
\LA{}algorithm for testing hypness\RA{}
\LA{}is hyp?\RA{}
\nwendcode{}\nwbegindocs{103}\nwdocspar
\begin{thebibliography}{9}
\bibitem{Bonahon}
  F. Bonahon,
  \emph{Geometric structures on 3-manifolds},
  Chapter 3 from \emph{Handbook of Geometric Topology},
  ed. R. J. Daverman and R. B. Sher, Elsevier, New York, 2002.
\bibitem{Regina}
  B. A. Burton, R. Budney, W. Pettersson, et al.,
  \emph{{\Tt{}Regina\nwendquote}: software for 3-manifold topology 
  and normal surface theory},
  http://regina.sourceforge.net/ , 1999--2014.
\bibitem{Me}
  Robert C. Haraway, III,
  \emph{Determining hyperbolicity of 
   multiply-cusped 3-manifolds},
  preprint available at author's website.
\bibitem{JT95}
  W. Jaco and J. L. Tollefson,
  \emph{Algorithms for the complete decomposition
   of a closed 3-manifold},
  Illinois J. of Math., \textbf{39}:3, Fall 1995, pp. 358--406.
\bibitem{Kapovich}
  M. Kapovich,
  \emph{Hyperbolic manifolds and discrete groups},
  Birkh\"auser, Boston, 2001.
\bibitem{Marden}
  A. Marden,
  \emph{Outer circles: an introduction to hyperbolic 3-manifolds},
  Cambridge University Press, New York, 2007.
\bibitem{Matveev}
  S. Matveev,
  \emph{Algorithmic topology and classification of 3-manifolds},
  Springer-Verlag, New York, 2003.
\bibitem{T82}
  W. P. Thurston,
  \emph{Three-dimensional manifolds, Kleinian groups 
  and hyperbolic geometry},
  Bull. Amer. Math. Soc. (N.S.) \textbf{6}:3 (1982), 357--381.
\bibitem{Tol98}
  J. L. Tollefson,
  \emph{Normal surface Q-theory},
  Pacific J. of Math., \textbf{183}:2 (1998), 359--374.
\end{thebibliography}
\end{document}
\nwenddocs{}
